
-- create a table which contains all the catalogues meta-data
-- in particular for each catalogue contains a path which indicates
-- where the real database of the catalogue is stored
create table APP.CATALOGUE(

	-- the id of the catalogue, internally defined
	--CAT_ID integer not null primary key generated always as identity ( start with 1, increment by 1 ),
	
	-- the catalogue version must be unique! We can store different version of the same catalogue
	-- but not the same version multiple times
	CAT_CODE varchar(50) not null,
	CAT_VERSION varchar(50) not null,
	CAT_NAME varchar(300),
	
	-- the catalogue label, this is the name that is shown to the user
	CAT_LABEL varchar(300),
	CAT_SCOPENOTE varchar(3000),
	CAT_TERM_CODE_MASK varchar(50),
	CAT_TERM_CODE_LENGTH integer,
	CAT_TERM_MIN_CODE varchar(50),
	CAT_ACCEPT_NON_STANDARD_CODES boolean default true, 
	CAT_GENERATE_MISSING_CODES boolean default false,
	CAT_STATUS varchar(200),
	CAT_GROUPS varchar(1000),
	CAT_LAST_UPDATE timestamp,
	CAT_VALID_FROM timestamp,
	CAT_VALID_TO timestamp,
	CAT_DEPRECATED boolean default false,
	
	CAT_IS_LOCAL boolean,  -- if the catalogue is a local catalogue or not
	
	-- external reference to retrieve the database
	-- which contains all the catalogue data
	CAT_DB_PATH varchar(1000) not null,
	
	-- the path where is located a copy of
	-- the db before starting editing it
	-- only applicable for internal versions
	-- of catalogues
	CAT_DB_BACKUP_PATH varchar(1000),
	
	primary key ( CAT_CODE, CAT_VERSION )
);

-- table of corex flags, we assume that these are always the same for all the catalogues
create table APP.DETAIL_LEVEL(

	DETAIL_LEVEL_ID integer not null primary key generated always as identity (start with 1, increment by 1),
	
	-- its code (h, m, f...)
	DETAIL_LEVEL_CODE varchar(1),
	
	-- the human readable name
	DETAIL_LEVEL_LABEL varchar(500),
	
	-- the image name related to the detail level
	DETAIL_LEVEL_IMAGE_NAME varchar(1000)
);

-- add the unique contraint to the code field
alter table APP.DETAIL_LEVEL add constraint detail_level_code_unique unique ( DETAIL_LEVEL_CODE );


-- insert the values for the detail levels
insert into APP.DETAIL_LEVEL (DETAIL_LEVEL_CODE, DETAIL_LEVEL_LABEL, DETAIL_LEVEL_IMAGE_NAME) values
	('H', 'Hierarchy term', 'Pyramid.ico'),
	('C', 'Core term', 'RedSphere.ico'),
	('E', 'Extended term', 'GreenSphere.ico'),
	('F', 'Facet descriptor', 'Facet.ico'),
	('M', 'Aggregation term', 'WhiteSphere.ico'),
	('P', 'Non-specific term', 'YellowSphere.ico');


-- table to track the reserve operations
-- of the users
create table APP.RESERVED_CATALOGUE (

	CAT_CODE varchar(50) not null,
	CAT_VERSION varchar(50) not null,
	RESERVE_USERNAME varchar(100) not null,
	RESERVE_LEVEL varchar(50) not null,
	
	-- CAT_CODE and VERSION as primary key, 
	-- we cannot reserve the same catalogue
	-- twice!
	primary key ( CAT_CODE, CAT_VERSION )
);

-- table to track the catalogues
-- which their editing was forced
create table APP.FORCED_CATALOGUE (

	CAT_CODE varchar(50) not null,
	CAT_VERSION varchar(50) not null,
	FORCED_USERNAME varchar(100) not null,
	FORCED_EDIT boolean not null,
	
	-- CAT_CODE and VERSION as primary key
	-- we cannot forced the editing of the 
	-- same catalogue in two different ways
	primary key ( CAT_CODE, CAT_VERSION )
);

-- table to save the preferred dimensions
-- of the dialogs (as describe window..)
create table APP.WINDOW_PREF (

	WINDOW_CODE varchar(50) primary key,  -- code to identify the window
	WINDOW_X integer not null,  -- x position
	WINDOW_Y integer not null,  -- y position
	WINDOW_W integer not null,  -- width
	WINDOW_H integer not null,  -- height
	WINDOW_MAX boolean not null -- true if the window should be maximized
);

-- This table stores all the user preferences related to the whole application. 
-- We use the logic "key value"

create table APP.PREFERENCE (
	PREFERENCE_ID integer not null primary key generated always as identity (start with 1, increment by 1),
	PREFERENCE_KEY varchar(500),   -- key of the preference
	PREFERENCE_TYPE varchar(500),  -- type of the preference (integer, string, boolean)
	PREFERENCE_VALUE varchar(3000) -- value of the preference
);

-- add the unique contraint to the key field
alter table APP.PREFERENCE add constraint preference_key_unique unique ( PREFERENCE_KEY );


-- This table stores all the pending requests for reserving or unreserving
-- catalogues. All these requests are retried in background!
create table APP.PENDING_RESERVE (
	RESERVE_ID integer not null primary key generated always as identity (start with 1, increment by 1),
	RESERVE_LOG_CODE varchar(500) not null, -- code of the log related to the pending reserve action
	RESERVE_LEVEL varchar(50) not null,     -- the reserve level (none, minor, major)
	CAT_CODE varchar(50) not null,          -- code of the catalogue we are reserving
	CAT_VERSION varchar(50) not null,       -- version of the catalogue we are reserving
	RESERVE_USERNAME varchar(50) not null   -- the name of the user which made the reserve
);

-- add the unique contraint to the log id field
alter table APP.PENDING_RESERVE add constraint log_code_unique unique ( RESERVE_LOG_CODE );

-- set the foreign keys for PENDING_RESERVE table
alter table APP.PENDING_RESERVE add foreign key ( CAT_CODE, CAT_VERSION ) references APP.CATALOGUE ( CAT_CODE, CAT_VERSION );
